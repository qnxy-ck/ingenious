namespace com.demo.mapper

import entity com.demo.data.entity.UserInfo



// mapping 定义返回结果
// xxx 定义的名称
// 返回的具体类型
mapping xxx CustomUserInfo {

    // 属性名称 字段名称(如果字段名称和属性名称一样则不需要) -> 这里会得到该值this指向, 转换函数(不需要转换则不写)
    birthday    user_birthday -> ::dateFormatting("yyyy-MM-dd")
    username
    
    // 在属性前增加 ! 表示该属性不查询
    !age
    gender
    email
    // 该类型的属性会自动进行转换 -> user_status
    userStatus

}


// 查询全部
// 如果查询全部则无需单独声明, 直接返回该类即可
mapping yyy CustomUserInfo {
    ...
}


// 如果需要要查询全部, 但是部分字段和属性名称不一致, 仅需要写出不一样的并且最后加上 ... 即可
mapping zzz CustomUserInfo {
    birthday user_birthday
    ...
}


// 继承机制
// 对被继承者的补充
mapping sss CustomUserInfo by xxx {
    creationTime created_at -> ::dateFormatting("yyyy-MM-dd")
    
}


// 返回结果映射需要配合 #smart_column 使用
// 如果结果映射定义了三个字段, 查询了四个字段则多出的那个字段将会被忽略
// 如果查询四个定义三个, 未被查询的定义则无法处理
// 配合 #smart_column 使用后, 则会自动根据定义查询指定字段

// 批量查询
search selectByUsername(username: String): multi by xxx {

    select #smart_column
        from user_info
            where username = :username?
        
}

// 单条查询
search selectById(id: Long?): by xxx {

    select #smart_column
        from user_info
            where id = :id
        
}


select max(age) age, username
    from user_info
    where id = :id
    group by username
    


// ----------------------------------------------------------------
// 提案二

search selectByUsername(username: String): UserInfo {
    select
        // 每行只可控制一个字段
        
        // 字段           属性(可选)  转换函数(可选)
        max(age),       => maxAge
        // 名称相同不需要写
        username, user_status,
        user_birthday   => birthday
        created_at      => creationTime::dateFormatting("yyyy-MM-dd")
    from user_info
        where id #in :idList
        group by username
}
    