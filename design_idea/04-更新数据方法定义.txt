namespace com.demo.mapper

import entity com.demo.data.entity.UserInfo


// 更新一条记录
// update 更新方法定义关键字
// updateUserInfo 更新方法名称
// userInfo: UserInfo 参数信息
// 默认返回更新影响行数 (Long)
// 如果需要返回布尔值, 则需手动指定
// 如: update boolean updateUserInfo(userInfo: UserInfo) { }
update updateUserInfo(userInfo: UserInfo) {

    // 原始方式
    update user_info
        set
            username = :userInfo.username,
            age = :userInfo.age,
            email = :userInfo.email,
            birthday = :userInfo.birthday
        where id = :userInfo.id


    // 进阶方式
    // 如果更新数据的表为当前实体对应表 表名可以省略
    #update_set user_info :userInfo {
        // 对指定字段进行更新, 如果更新字段名称和当前对象属性名称一样可以省略等号前的内容
        username = :username
        :age
        :email
        :birthday::notNull  // 如果当前属性为空则不进行sql的拼接, 该字段就不会更新
    }
    where id = :userInfo.id
    
}


// 逻辑删除一条记录
update boolean logicalDelete(id: Long) {

    // 逻辑删除指定记录
    // 等价sql
    // update user_info set deleted = true where id = :id
    // 如果更新数据的表为当前实体对应表 表名可以省略
    // 如: #update_logical_delete :id
    // tips: 那么这样实现的话, 怎么知道那个是逻辑字段呢? 把逻辑字段修改成什么值呢?
    // 这个目前觉得在表对应实体类种进行配置比较合适
    #update_logical_delete user_info :id
    
}

// 逻辑恢复一条数据
update updateLogicalRecoveryById(id: Long) {
    #update_logical_recovery :id
}


// 逻辑删除多条记录
update boolean batchLogicalDelete(idList: List<Long>) {

    // 相对于单个逻辑删除, 仅需要加一个 multi 标记即可
    // 等价sql
    // update user_info set deleted = true where id in (?, ?, ?)
    #update_logical_delete user_info multi :idList

}
